path_settings={}path_settings.table_coordinates={INI={x=200,y=200},S6={x=2000,y=200},S1={x=250,y=150},S1EO={x=450,y=0},S1ER={x=450,y=120},A8={x=500,y=400},P6B={x=1500,y=400}}path_settings.edges={INI={"S6","A8"},S6={"INI","P6B"},A8={"INI","P6B"},P6B={"S6","A8"}}config={}config.MATCH_DURATION_MS=87000;config.DEFAULT_LOOP_PERIOD_MS=50;config.ENNEMY_RADIUS_MM=200;config.SCAN_DURATION_MS=330;config.US_DECAY_TIME_MS=500;config.OVERSHOOT_MM=100;config.ROBOT_CENTER_Y_BOTTOM=200;config.PANEL_ARM_TIMEOUT_MS=250;config.theta_pince_mur=-0.52359877559;local a={}a.us_channels={us1=0,us2=0,us3=0,us4=0,us5=0,us6=0,us7=0,us8=0,us9=0,us10=0}a.us_angles={us1=36,us2=72,us3=108,us4=144,us5=180,us6=216,us7=252,us8=288,us9=324,us10=360}a.us_timestamp={us1=0,us2=0,us3=0,us4=0,us5=0,us6=0,us7=0,us8=0,us9=0,us10=0}a.last_pose={x=0,y=0,theta=0}Queue={}function Queue.new()return{first=0,last=-1}end;function Queue.push(b,value)local c=b.last+1;b.last=c;b[c]=value end;function Queue.pop(b)local d=b.first;if d>b.last then error("list is empty")end;local value=b[d]b[d]=nil;b.first=d+1;return value end;function Queue.is_empty(b)return b.first>b.last end;function a.escrall(e,...)local status,f=pcall(e,...)if not status then print(f)end end;function a.get_edges(g)for h,i in pairs(g)do print(h)for j,k in pairs(i)do print(k)end end;return end;function a.backtrace(l,m,n)local o={}local h=n;while h~=m do table.insert(o,1,h)h=l[h]end;table.insert(o,1,m)return o end;function a.get_shortest_path(g,m,n)local l={}local p={}local q=Queue.new()p[m]=true;Queue.push(q,m)while not Queue.is_empty(q)do local h=Queue.pop(q)if h==n then return a.backtrace(l,m,n)end;for j,k in pairs(g[h])do if not p[k]then p[k]=true;l[k]=h;Queue.push(q,k)end end end end;function a.get_distance(r,s,t,u)return math.sqrt((t-r)^2+(u-s)^2)end;function a.is_point_in_circle(v,w,x,y,z)return a.get_distance(v,w,x,y)<=z end;function a.get_valid_pt(A,B,C,D)local E,F=nil,100000;for G,i in pairs(path_settings.table_coordinates)do local H=a.get_distance(A,B,i.x,i.y)if H<F and a.is_point_in_circle(i.x,i.y,C,D,config.ENNEMY_RADIUS_MM)then E=G;F=H end end;return E end;function a.reach_closest_waypoint(A,B,I,J)end;function a.update_us_channels(K)local L={get_us_readings()}for G,i in pairs(L)do if a.us_channels[G]~=i then a.us_channels[G]=i;a.us_timestamp[G]=K end end end;function a.get_opfor_position(K)a.update_us_channels(K)local M,N,O=get_pose()local F=100000;local P,Q=nil,nil;for G,i in pairs(a.us_channels)do if K-a.us_timestamp[G]<config.US_DECAY_TIME_MS then local R=a.us_angles[G]local v=M+i*math.cos(O+R)local w=N+i*math.sin(O+R)local H=a.get_distance(M,N,v,w)if H<F then F=H;P,Q=v,w end end end;return P,Q end;local S={}S.__index=S;local T="none"local U="async"local function V(W,X)if W then return W(table.unpack(X))end end;local function Y(Z)local _,a0,a1,X;local function a2(self,...)if self.asyncState==T then _,a0=self:can(Z)a1=self.current;X={self,Z,a1,a0,...}if not _ then return false end;self.currentTransitioningEvent=Z;local a3=V(self["onbefore"..Z],X)local a4=V(self["onleave"..a1],X)if a3==false or a4==false then return false end;self.asyncState=Z.."WaitingOnLeave"if a4~=U then a2(self,...)end;return true elseif self.asyncState==Z.."WaitingOnLeave"then self.current=a0;local a5=V(self["onenter"..a0]or self["on"..a0],X)self.asyncState=Z.."WaitingOnEnter"if a5~=U then a2(self,...)end;return true elseif self.asyncState==Z.."WaitingOnEnter"then V(self["onafter"..Z]or self["on"..Z],X)V(self["onstatechange"],X)self.asyncState=T;self.currentTransitioningEvent=nil;return true else if string.find(self.asyncState,"WaitingOnLeave")or string.find(self.asyncState,"WaitingOnEnter")then self.asyncState=T;a2(self,...)return true end end;self.currentTransitioningEvent=nil;return false end;return a2 end;local function a6(a7,a8)if type(a8.from)=='string'then a7[a8.from]=a8.to else for j,a1 in ipairs(a8.from)do a7[a1]=a8.to end end end;function S.create(a9)assert(a9.events)local aa={}setmetatable(aa,S)aa.options=a9;aa.current=a9.initial or'none'aa.asyncState=T;aa.events={}for j,a8 in ipairs(a9.events or{})do local Z=a8.name;aa[Z]=aa[Z]or Y(Z)if aa.events[Z]==nil then aa.events[Z]={map={}}end;a6(aa.events[Z].map,a8)end;for Z,ab in pairs(a9.callbacks or{})do aa[Z]=ab end;return aa end;function S:is(ac)return self.current==ac end;function S:can(ad)local a8=self.events[ad]local a0=a8 and a8.map[self.current]or a8.map['*']return a0~=nil,a0 end;function S:cannot(ad)return not self:can(ad)end;function S:todot(ae)local af=io.open(ae,'w')af:write('digraph {\n')local a2=function(a8,a1,a0)af:write(string.format('%s -> %s [label=%s];\n',a1,a0,a8))end;for j,a8 in pairs(self.options.events)do if type(a8.from)=='table'then for j,a1 in ipairs(a8.from)do a2(a8.name,a1,a8.to)end else a2(a8.name,a8.from,a8.to)end end;af:write('}\n')af:close()end;function S:transition(a8)if self.currentTransitioningEvent==a8 then return self[self.currentTransitioningEvent](self)end end;function S:cancelTransition(a8)if self.currentTransitioningEvent==a8 then self.asyncState=T;self.currentTransitioningEvent=nil end end;S.NONE=T;S.ASYNC=U;local ac={}ac.__index=ac;ac.Recovery={CNL={},PUSHBCK={},AROUND={},WAIT_2S={}}ac.recovery_method=ac.Recovery.CNL;ac.destination={}ac.end_scan_stamp=nil;ac.timer={}ac.timer.set=function(K,ag,ab)ac.timer.start=K;ac.timer.duration_left=ag;ac.timer.callback=ab or nil end;ac.timer.is_done=function(K)if K-ac.timer.start>ac.timer.duration_left then if ac.timer.callback~=nil then ac.timer.callback()ac.timer.start=nil;ac.timer.duration_left=nil;ac.timer.callback=nil end;return true else return false end end;function ac.scan_and_wait_us(aa,Z,a1,a0,ah,K)ah:scan_and_wait_inf()scan_channels(tonumber("1111111111",2))if ac.timer.start~=nil then error("state.can_and_wait_us: timer already set - resseting it")end;ac.timer.set(K,config.SCAN_DURATION_MS,function()aa:transition(Z)ah:end_scan()end)return aa.ASYNC end;ac.movement_state=S.create({initial="done",events={{name="move_safe",from={"done","recovering"},to="moving_safe"},{name="move_blind",from={"done","recovering"},to="moving_blind"},{name="set_done",from={"moving_blind","moving_safe"},to="done"},{name="stop",from="moving_safe",to="stopped"},{name="scan_over",from="stopped",to="recovering"}},callbacks={onstop=function(self,a8,a1,a0,K)end,onscan_over=function(aa,Z,a1,a0,K)end}})ac.get_wpt_coords=function(ai)if path_settings.table_coordinates[ai]==nil then error("state.get_wpt_coords: invalid waypoint : "..tostring(ai))end;return path_settings.table_coordinates[ai].x,path_settings.table_coordinates[ai].y end;ac.movement_state.onmove_safe=function(aa,Z,a1,a0,v,w,aj)ac.destination.x=v;ac.destination.y=w;ac.destination.theta=aj;set_pose(v,w,aj,true)end;ac.movement_state.onmove_blind=function(aa,Z,a1,a0,v,w,aj)ac.destination.x=v;ac.destination.y=w;ac.destination.theta=aj;set_pose(v,w,aj,false)end;ac.movement_state.onset_stopped=function(aa,Z,a1,a0,K)scan_channels(tonumber("1111111111",2))ac.end_scan_stamp=K+config.SCAN_DURATION_MS end;ac.movement_state.onscan_over=function(aa,Z,a1,a0,K)ac.movement_state:move_safe(ac.destination.x,ac.destination.y,ac.destination.theta)end;ac.action_state=S.create({initial="idle",events={{name="scan_and_wait_inf",from="idle",to="scanning"},{name="end_scan",from="scanning",to="idle"},{name="do_nothing",from='*',to="idle"},{name="move_S1",from='*',to="sticking_wall_S1"},{name="follow_wall_S1",from='*',to="following_wall_S1"}}})ac.actions={}ac.action_state.onmove_S1=function(aa,Z,a1,a0,K)print("beg act_solar_S1_to_S1_init")move_servo(1,3000)local v,w=ac.get_wpt_coords("S1")ac.movement_state:move_safe(v,w,config.theta_pince_mur)ac.movement_state.ondone=function(self,a8,a1,a0)local v,w=get_pose()local ak,al=v,config.ROBOT_CENTER_Y_BOTTOM-config.OVERSHOOT_MM;ac.movement_state:move_blind(ak,al,config.theta_pince_mur-0.1*1)ac.movement_state.ondone=function(self,a8,a1,a0)ac.action_state:follow_wall_S1()ac.movement_state.ondone=nil end end end;ac.action_state.onfollow_wall_S1=function(aa,Z,a1,a0)local ak,al=ac.get_wpt_coords("S1EO")ac.movement_state:move_safe(ak,al,config.theta_pince_mur-0.1*2)ac.movement_state.ondone=function(self,a8,a1,a0)ac.action_state:do_nothing()end end;ac.actions.following_wall_S1={}ac.actions.following_wall_S1.start_stamp=nil;ac.actions.following_wall_S1.panel_count=0;ac.actions.following_wall_S1.left_contactor=0;ac.actions.following_wall_S1.loop=function(K)if get_button(101)==true then move_servo(1,6000)end end;ac.action_order={}ac.action_order[1]=ac.action_state.move_S1;function ac.loop(K)if ac.timer.duration_left~=nil then ac.timer.is_done(K)end;if is_motion_done()then ac.movement_state:set_done(K)end;if ac.movement_state.current=="stopped"and K>ac.end_scan_stamp then ac.movement_state:scan_over(K)end;if ac.action_state.current=="idle"then if ac.action_order[1]~=nil or true then print("dequeuing action "..tostring(ac.action_order[1]))table.remove(ac.action_order,1)(ac.action_state,K)end end;for G,i in pairs(ac.actions)do if ac.action_state.current==G then if i.loop~=nil then i.loop()else print("strange_behaviour for action_state")end end end end;x_initial,y_initial,theta_initial=path_settings.table_coordinates.INI.x,path_settings.table_coordinates.INI.y,0;main_loop=nil;is_right=nil;start_time=nil;test_function_done=false;function on_init(am)is_right=am;overwrite_pose(x_initial,y_initial,theta_initial)move_servo(1,6000)print("init done ! ")end;function on_loop(K)if start_time==nil then start_time=K end;ac.loop(K)return config.DEFAULT_LOOP_PERIOD_MS end;function create_coroutine()main_loop=coroutine.create(function(K)start_time=K;while true do if K-start_time>config.MATCH_DURATION_MS then on_end()break end;sleep_period=on_loop(K)K=coroutine.yield(sleep_period)end end)end;function resume_loop(K)if main_loop==nil then create_coroutine()end;status,value=coroutine.resume(main_loop,K)if coroutine.status(main_loop)=="dead"then print("lua script crashed at : ")print(tostring(value))print(debug.traceback(main_loop))main_loop=-2;return-2 end;return value end;function on_end()print("Score: 0")end